# June 9, 2024

## Recap

The last time I wrote I had finished spliting out my kernel and kernel loading code. I have since managed to get the kernel ELF image included in the kernel loader.
This is a temporary solution for storing and loading the kernel while I do not currently have a file system.

For a little bit however the kernel loader would not work. I later found out that my memory management code was hanging because I had misconfigured it.
Some of the magic around finding the end of the kernel loader image in memory was return 0 and when my `memory_blocks` class attempted to initialize and write to location 0, the CPU hangs.

I have finnally resolved this issue and now on to my next task... actually parsing the ELF binary into memory.

## Parsing ELF Binaries

I have long known that I would use ELF binaries and have documented where I could get basic information on them here [ELF Documentation](https://wiki.osdev.org/ELF).

Before getting to this point however I decided to figure out how I would structure my ELF reading logic. I'm sure anyone reading this might have the urge to just Google some code online they can import to do this work.
I like writing things myself. Who knows, I might have a novel approach. At the very least I'll learn something.

Since I'm using C++ my approach is to have go for and elf_reader class that can take in a binary stream and turn it into a searchable abstraction.

```cpp

void* kernel_file_here = 0xBAADF00D;
memory_stream elf_stream(kernel_file_here);
elf_reader reader(elf_stream);

while(reader.has_more_segments())
{
    elf_segment segment = reader.current_segment();

    // Map segment into memory and set it's permissions.

    reader.next_segment();
}

```

I'm going to have define my stream and memory_stream classes. I'm sure these will come in handy. I will liken them to the Stream and MemoryStream C# classes I'm so used to using.
I'm sure some C++ developer is screaming in horror that I'm bringing some C# paradigms to my C++ code.

Also... I'm finally getting the difference between reinterpret_cast and static_cast. I'm really old school when it comes to C++. In my day job I deal with a lot of legacy C++ code that doesn't use these keywords at all.
That said StackOverflow says reinterpret_cast is dangerous. That said I'm sure when writing an OS you NEED to do a lot of "dangerous" stuff. Especially since a lot of helper code is not available to you.

I'm tired however. It's been a long day after running in a Pride themed 5K. I'm going to bed.
